(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{362:function(t,a,s){"use strict";s.r(a);var r=s(9),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http协议初步探究"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http协议初步探究"}},[t._v("#")]),t._v(" HTTP协议初步探究")]),t._v(" "),s("h2",{attrs:{id:"http概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http概念"}},[t._v("#")]),t._v(" HTTP概念")]),t._v(" "),s("p",[t._v("​\t\tHTTP协议是超文本传输协议，用于约束与规范客户机向服务器发送请求、服务器向客户机发送响应的过程。简而言之，当向服务器发送请求时，需要遵循http协议的相关规定。有一个需要记住的点，HTTP的默认端口为80，HTTPS协议的默认端口是443。")]),t._v(" "),s("h2",{attrs:{id:"了解tcp-ip协议栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#了解tcp-ip协议栈"}},[t._v("#")]),t._v(" 了解TCP/IP协议栈")]),t._v(" "),s("p",[t._v("​\t\t在深入了解HTTP协议之前，我们需要先了解一下TCP/IP协议栈。TCP/IP协议栈不单指TCP、IP两个协议，它是由许多协议组成的一个协议簇。与OSI七层架构不同的是，TCP/IP协议簇分为四层：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n应用层：为用户提供所需的各种服务，例如：HTTP、FTP、DNS、SMTP等\n传输层：为应用层实体提供端到端的通信功能，保证数据包的顺序传输及数据的完整性。该层主要定义了传输控制协议（TCP）和用户数据报协议（UDP）。\n网络层：主要解决主机到主机的通信问题，最主要的是IP协议。\n网络接口层：负责监视数据在主机和网络之间的交换\n*/")]),t._v("\n")])])]),s("h3",{attrs:{id:"tcp和udp的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[t._v("#")]),t._v(" TCP和UDP的区别")]),t._v(" "),s("p",[t._v("​\t\t用户数据报协议（UDP）是面向报文的数据，在发送数据前不需要建立链接，直接发送报文，且既可以一对一，也可以一对多，多对多，是不可靠的协议。")]),t._v(" "),s("p",[t._v("​\t\t传输控制协议（TCP）是面向链接的协议，在传输数据前需要建立链接，然后进行一对一的数据传输，是可靠的协议。")]),t._v(" "),s("p",[t._v("​\t\t在TCP协议建立链接之前，会进行三次握手：客户端向服务端发送链接请求、服务端发送应答、客户端再向服务端发送确认报文。TCP协议断开链接时，会进行四次挥手：客户端向服务端发送释放链接请求，服务端发送确认报文；服务端发送完所有数据后，向客户端发送释放链接请求；客户端向服务端发送确认请求。")]),t._v(" "),s("h2",{attrs:{id:"http协议工作过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http协议工作过程"}},[t._v("#")]),t._v(" HTTP协议工作过程")]),t._v(" "),s("p",[t._v("​\t\t一次HTTP操作称为一个事务，其工作过程可分为四步：")]),t._v(" "),s("p",[t._v("1、首先客户机与服务器建立连接，这里依靠TCP协议。")]),t._v(" "),s("p",[t._v("2、客户机向服务器发送一个请求，请求方式的格式为：统一资源标识符（URL）、协议版本号、后边是MIME信息，包括请求修饰符、客户机信息和可能的内容。")]),t._v(" "),s("p",[t._v("3、服务器接到请求后，给与相应的响应信息。其格式包括一个状态行、协议号版本号、状态码、后边是MIME信息，包括服务器信息、实体信息和可能的内容。")]),t._v(" "),s("p",[t._v("4、客户机收到响应，然后断开链接，这里依靠TCP协议。")]),t._v(" "),s("p",[t._v("​\t\t这四步中，任何一步若出现问题，即视为操作失败，整个操作作废。一个HTTP请求是无状态的,即服务器不能分辨客户端的信息。")]),t._v(" "),s("h2",{attrs:{id:"请求和响应的组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求和响应的组成"}},[t._v("#")]),t._v(" 请求和响应的组成")]),t._v(" "),s("h3",{attrs:{id:"请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求"}},[t._v("#")]),t._v(" 请求")]),t._v(" "),s("p",[t._v("​\t\tHTTP请求组成：请求行、消息报头、请求正文。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n请求行：GET/ 路径 / HTTP / 1.1  分别为请求方式，路径，协议名称与版本号\n报文头：由键值对组成，常见的请求报头有：Accept:浏览器接收的数据格式；Accept-Encoding:接收数据是否能压缩；keep-alive：长链接或短链接\n报文体：请求所传的参数，当请求方式为get时，可以为空\n*/")]),t._v("\n")])])]),s("h3",{attrs:{id:"响应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应"}},[t._v("#")]),t._v(" 响应")]),t._v(" "),s("p",[t._v("​\t\tHTTP响应组成:状态行、消息报文、响应正文。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n状态行： HTTP / 1.1 200 OK  分别为协议名称与版本号，状态码与状态码描述\n响应头：由键值对组成\n响应体：服务器返回的数据\n*/")]),t._v("\n")])])]),s("h2",{attrs:{id:"http状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n1xx 指示消息--表示请求已接受，继续处理\n2xx 成功，表示请求已被成功接收、理解、接受\n3xx 重定向，要完成请求必须进行更进一步的操作\n4xx 客户端错误，请求有语法错误或请求无法实现\n5xx 服务端错误，服务器未能实现合法的请求\n*/")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);